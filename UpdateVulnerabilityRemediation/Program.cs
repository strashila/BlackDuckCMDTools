using System;
using System.Collections.Generic;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using System.IO;
using System.Linq;
using System.Net.Http;
using BlackDuckCMDTools;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace GetAllProjectsWithVersionCount
{
    class Program
    {
        static int Main(string[] args)
        {

            /// Uses the beta System.CommandLine library to parse command line arguments 
            /// https://github.com/dotnet/command-line-api/blob/main/docs/Your-first-app-with-System-CommandLine.md


            var _bdurl = new Option<string>(
                "--bdurl",
                description: "REQUIRED: BlackDuck URL"
                );

            var _token = new Option<string>(
                "--token",
                description: "REQUIRED: BlackDuck Token"
                );


            var _projectname = new Option<string>(
                "--projectname",
                description: "REQUIRED: Project name"                
                );

            var _notsecure = new Option<bool>(
                "--not-secure",
                description: "Trust the certificate of the BD server",
                getDefaultValue: () => false
                );



            var rootCommand = new RootCommand
            {
                _bdurl,
                _token,
                _projectname,
                _notsecure                
            };


            // The new command handler API
            // https://learn.microsoft.com/en-us/dotnet/standard/commandline/get-started-tutorial


            rootCommand.SetHandler(
            (string bdUrl, string token, string projectName, bool notSecure) =>
            {
                BlackDuckCMDTools.BlackDuckRestAPI bdapi;

                var hardcodedSearchParams = $"?offset=0&limit=1000"; //used to get versions and projects                        


                if (token == null || bdUrl == null || projectName == null)
                {
                    Console.WriteLine("Parameters missing, use --help");
                    return;
                }

                else
                {
                    if (bdUrl.LastIndexOf("/") == bdUrl.Length - 1) // URL ends with "/"
                    {
                        bdUrl = bdUrl.Remove(bdUrl.LastIndexOf("/"));
                    }
                }


                /// Trying to create connection to the API both secure and not-secure methods (trusting all SSL certificates or not).
                /// Catching errors both times

                if (notSecure)
                {
                    try
                    {
                        bdapi = new BlackDuckCMDTools.BlackDuckRestAPI(bdUrl, token, false);
                    }

                    catch (Exception ex)
                    {
                        // catching AuthenticationException or HttpRequestException
                        if (ex is System.AggregateException || ex is HttpRequestException || ex is System.Net.Sockets.SocketException || ex is System.Security.Authentication.AuthenticationException)
                        {
                            Console.WriteLine($"\nError: {ex.Message}");
                        }
                        return;
                    }
                }

                else
                {
                    try
                    {
                        bdapi = new BlackDuckCMDTools.BlackDuckRestAPI(bdUrl, token, true, 1200);    // Setting 20 minutes timeout in the constructor overload                  
                    }

                    catch (Exception ex)
                    {
                        // catching AuthenticationException or HttpRequestException

                        if (ex is System.AggregateException || ex is HttpRequestException || ex is System.Net.Sockets.SocketException || ex is System.Security.Authentication.AuthenticationException)
                        {
                            Console.WriteLine($"\nError: {ex.Message}");
                        }
                        return;
                    }
                }



                try
                {
                    
                    var projectId = bdapi.GetProjectIdFromName(projectName);


                    var projectVersions = bdapi.GetProjectVersionsFromProjectId(projectId, hardcodedSearchParams);

                    string bodyStatusNew = new JObject(
                           new JProperty("remediationStatus", "NEW")
                           ).ToString();

                    var totalDictOfAllProjectVulnerableComponents = new Dictionary<BlackDuckVulnerableBomComponent, string>();

                    // Setting all the mitigation statuses to "NEW" for ALL the project versions 

                    Console.WriteLine();
                    Console.WriteLine($"Setting the remediation status of all remediated vulnerabilities for Project {projectName} to \"NEW\"");
                    Console.WriteLine();

                    foreach (var projectVersion in projectVersions)
                    {
                        var offset = 0;
                        var limit = 1000;
                        var remediatedCount = 0;
                        var additionalSearchParams = $"?offset={offset}&limit={limit}";


                        var versionId = projectVersion._meta.href.Split("/").Last();                       
                        var vulnerableComponents = bdapi.GetBOMsVulnerableComponents(projectId, versionId, additionalSearchParams);

                        Console.WriteLine();
                        Console.WriteLine($"Version {projectVersion.versionName} TOTAL vulnerable BOM components found: {vulnerableComponents.Count}");
                        Console.WriteLine();

                        while (vulnerableComponents.Count > 0)
                        {

                            foreach (var component in vulnerableComponents)

                            {
                                if (component.vulnerability.remediationStatus != "NEW") // We're only interested in components that have been mitigated
                                {
                                    remediatedCount++;
                                    totalDictOfAllProjectVulnerableComponents.Add(component, projectVersion.versionName);
                                    var response = bdapi.UpdateBomVulnerabilityRemediation(component, bodyStatusNew);
                                    Console.WriteLine($"Project {projectName} Version {projectVersion.versionName} Component {component.componentName} component_version {component.componentVersionName} vulnerability {component.vulnerability.vulnerabilityId} remediation_status {component.vulnerability.remediationStatus} Set to NEW {response}");
                                }                              

                            }

                            offset = offset + limit;
                            additionalSearchParams = $"?offset={offset}&limit={limit}";
                            vulnerableComponents = bdapi.GetBOMsVulnerableComponents(projectId, versionId, additionalSearchParams);


                            // removed this just in case, lets make another pass, what the heck
                            //
                            //  if (vulnerableComponents.Count < limit) // If the current batch of items is less than the limit, then we're reached the last page
                            //  {
                            //      break;
                            //  }

                            //  else  // If the current butch of items equals the limit then there are more pages available, and we shift the offset
                            //  {
                            // offset = offset + limit;
                            // additionalSearchParams = $"?offset={offset}&limit={limit}";
                            // vulnerableComponents = bdapi.GetBOMsVulnerableComponents(projectId, versionId, additionalSearchParams);

                            //   }
                        }
                    }



                    // Setting all mitigation statuses for what it used to be before


                    Console.WriteLine();
                    Console.WriteLine($"Setting the Remediation Status of all the remediated vulnerabilities for Project {projectName} back to the original status...");
                    Console.WriteLine();

                    Thread.Sleep(5000);

                    foreach (var kvpair in totalDictOfAllProjectVulnerableComponents)
                    {
                        var component = kvpair.Key;
                        string originalRemediation = component.vulnerability.remediationStatus;
                        string projectVersionName = kvpair.Value;

                        string bodyOriginalStatus = new JObject(
                               new JProperty("remediationStatus", originalRemediation)
                               ).ToString();

                        var response = bdapi.UpdateBomVulnerabilityRemediation(component, bodyOriginalStatus);
                        Console.WriteLine($"Project {projectName} Version {projectVersionName} Component {component.componentName} component_version {component.componentVersionName} vulnerability {component.vulnerability.vulnerabilityId} remediation_status {component.vulnerability.remediationStatus} {response}");

                    }

                }

                catch (Exception ex)
                {
                    // Catching Serialization errors
                    Console.WriteLine($"\nError {ex.Message}. Could not Serialize the API response. Please verify that you have correct BDurl, token, and Project Name");
                    return;
                }
                
            },

            _bdurl, _token, _projectname, _notsecure);

            return rootCommand.InvokeAsync(args).Result;
        }
    }
}
